# AWS Coding Agent - Implementation Workflow

**Project:** GitHub-integrated AI coding agent with OAuth authentication and streaming chat
**Architecture Source:** `/Users/freedom/ai/aws-coding-agent/draft.md`
**Estimated Timeline:** 18-26 hours (parallel) | 28-36 hours (sequential)
**Generated:** 2025-10-29

---

## Executive Summary

This workflow provides a structured implementation plan for building an AWS-based AI coding agent with:
- **GitHub OAuth Integration** (3-Legged OAuth via AgentCore)
- **Streaming Chat Interface** (FastAPI + SSE)
- **PR Review Automation** (GitHub API integration)
- **Functional Python Architecture** (minimal classes, separated prompts)

**Key Success Factors:**
1. OAuth provider must be created before any GitHub integration
2. Callback URL registration in GitHub OAuth App is CRITICAL
3. Use functional programming patterns (functions over classes)
4. Separate all prompts/templates from code files
5. Test OAuth flow early and continuously

---

## Phase Overview

| Phase | Description | Duration | Dependencies |
|-------|-------------|----------|--------------|
| **Phase 1** | Foundation & Project Setup | 2-3h | None |
| **Phase 2** | OAuth Infrastructure | 4-5h | Phase 1 |
| **Phase 3** | Core Agent Development | 3-4h | Phase 1, 2 |
| **Phase 4** | GitHub Integration | 4-5h | Phase 2, 3 |
| **Phase 5** | Streaming Chat Interface | 5-6h | Phase 3, 4 |
| **Phase 6** | Testing & Quality Assurance | 6-8h | All phases |
| **Phase 7** | Deployment & Validation | 4-5h | Phase 6 |

**Total Estimated Time:** 28-36 hours (sequential) | 18-26 hours (parallel)

---

## Phase 1: Foundation & Project Setup

**Goal:** Establish project structure, configuration, and utilities
**Duration:** 2-3 hours
**Dependencies:** None
**Parallel Opportunities:** All Phase 1 tasks can run concurrently

### Phase 1.1: Project Scaffolding

**Tasks:**
- [ ] Initialize project with uv or Poetry
  - Create `pyproject.toml` with dependencies
  - Add: `strands-agents`, `fastapi`, `uvicorn`, `pydantic`, `pydantic-settings`, `PyGithub`, `boto3`, `structlog`
  - Configure Python version (3.11+)

- [ ] Create directory structure
  ```
  coding-agent-mvp/
  ‚îú‚îÄ‚îÄ src/
  ‚îÇ   ‚îú‚îÄ‚îÄ config.py
  ‚îÇ   ‚îú‚îÄ‚îÄ prompts/
  ‚îÇ   ‚îú‚îÄ‚îÄ models/
  ‚îÇ   ‚îú‚îÄ‚îÄ auth/
  ‚îÇ   ‚îú‚îÄ‚îÄ agent/
  ‚îÇ   ‚îú‚îÄ‚îÄ tools/
  ‚îÇ   ‚îú‚îÄ‚îÄ chat/
  ‚îÇ   ‚îú‚îÄ‚îÄ utils/
  ‚îÇ   ‚îî‚îÄ‚îÄ main.py
  ‚îú‚îÄ‚îÄ scripts/
  ‚îú‚îÄ‚îÄ tests/
  ‚îú‚îÄ‚îÄ docs/
  ‚îî‚îÄ‚îÄ claudedocs/
  ```

- [ ] Setup version control
  - Create `.gitignore` (Python, AWS, IDE files)
  - Create `.env.example` with required variables
  - Initialize git repository

**Quality Gates:**
- ‚úì Project builds successfully (`uv sync` or `poetry install`)
- ‚úì All directories created per architecture spec
- ‚úì `.env.example` documents all required environment variables

### Phase 1.2: Configuration Infrastructure

**Tasks:**
- [ ] Implement `src/config.py`
  ```python
  from pydantic_settings import BaseSettings, SettingsConfigDict
  from pydantic import SecretStr

  class Settings(BaseSettings):
      model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')

      # AWS Configuration
      aws_region: str = "ap-southeast-2"
      model_id: str = "anthropic.claude-3-5-sonnet-20241022-v2:0"

      # GitHub OAuth
      github_client_id: SecretStr
      github_client_secret: SecretStr

      # Application
      log_level: str = "INFO"

  settings = Settings()
  ```

- [ ] Create `.env.example`
  ```
  AWS_REGION=ap-southeast-2
  MODEL_ID=anthropic.claude-3-5-sonnet-20241022-v2:0
  GITHUB_CLIENT_ID=your_github_client_id
  GITHUB_CLIENT_SECRET=your_github_client_secret
  LOG_LEVEL=INFO
  ```

- [ ] Create `.bedrock_agentcore.yaml` template
  ```yaml
  # Generated by: agentcore configure
  # This file will be populated after running agentcore configure
  oauth_configuration:
    workload_name: coding-agent-workload
    credential_providers:
      - github-provider
  ```

**Quality Gates:**
- ‚úì Configuration loads without errors
- ‚úì Environment variables validate correctly
- ‚úì SecretStr properly hides sensitive values in logs

### Phase 1.3: Logging & Utilities

**Tasks:**
- [ ] Implement `src/utils/logging.py`
  ```python
  import structlog

  def setup_logging(log_level: str = "INFO"):
      structlog.configure(
          processors=[
              structlog.stdlib.filter_by_level,
              structlog.stdlib.add_logger_name,
              structlog.stdlib.add_log_level,
              structlog.processors.TimeStamper(fmt="iso"),
              structlog.processors.StackInfoRenderer(),
              structlog.processors.format_exc_info,
              structlog.processors.JSONRenderer()
          ],
          wrapper_class=structlog.stdlib.BoundLogger,
          context_class=dict,
          logger_factory=structlog.stdlib.LoggerFactory(),
          cache_logger_on_first_use=True,
      )
  ```

- [ ] Implement `src/utils/response.py`
  ```python
  from typing import Any, Dict
  from datetime import datetime

  def format_sse_event(event_type: str, data: Any) -> str:
      """Format data as Server-Sent Event."""
      import json
      return f"data: {json.dumps({'type': event_type, 'data': data})}\n\n"

  def format_error_response(error: Exception) -> Dict[str, Any]:
      """Format error as JSON response."""
      return {
          "error": str(error),
          "type": type(error).__name__,
          "timestamp": datetime.utcnow().isoformat()
      }
  ```

**Quality Gates:**
- ‚úì Logging produces structured JSON output
- ‚úì Utility functions have type hints
- ‚úì No external dependencies beyond standard library + structlog

---

## Phase 2: OAuth Infrastructure

**Goal:** Setup GitHub OAuth authentication via AgentCore
**Duration:** 4-5 hours
**Dependencies:** Phase 1 complete
**Critical Path:** GitHub OAuth App ‚Üí Provider setup ‚Üí Authentication module

### Phase 2.1: GitHub OAuth App Setup (Manual)

**Tasks:**
- [ ] Create GitHub OAuth App
  - Go to https://github.com/settings/developers
  - Click "New OAuth App"
  - Fill in details:
    - Application name: "AWS Coding Agent"
    - Homepage URL: `https://your-domain.com` (or `http://localhost:8000` for dev)
    - Authorization callback URL: *Leave blank initially - will add after provider creation*
  - Click "Register application"

- [ ] Enable Device Flow
  - In OAuth App settings, find "Device Flow" section
  - Click "Enable Device Flow"
  - Save changes

- [ ] Store credentials securely
  - Copy Client ID
  - Click "Generate a new client secret"
  - Copy Client Secret immediately (shown only once)
  - Add both to `.env` file:
    ```
    GITHUB_CLIENT_ID=your_actual_client_id
    GITHUB_CLIENT_SECRET=your_actual_client_secret
    ```

**Quality Gates:**
- ‚úì OAuth App created and visible in GitHub settings
- ‚úì Device Flow enabled
- ‚úì Client ID and Secret stored in `.env`

### Phase 2.2: OAuth Provider Creation

**Tasks:**
- [ ] Implement `src/auth/setup_provider.py`
  ```python
  """Setup OAuth2 credential provider for GitHub authentication."""
  import boto3
  import time
  from ..config import settings

  def create_github_oauth_provider() -> str:
      """Create OAuth2 provider in AgentCore Identity."""
      client = boto3.client('bedrock-agentcore-control',
                           region_name=settings.aws_region)

      # Delete existing if present
      try:
          providers = client.list_oauth2_credential_providers()
          if any(p['name'] == 'github-provider'
                for p in providers.get('credentialProviders', [])):
              print("‚ôªÔ∏è  Deleting existing provider...")
              client.delete_oauth2_credential_provider(
                  name='github-provider'
              )
              time.sleep(5)
      except Exception as e:
          print(f"No existing provider: {e}")

      # Create new provider
      response = client.create_oauth2_credential_provider(
          name='github-provider',
          credentialProviderVendor='GithubOauth2',
          oauth2ProviderConfigInput={
              'githubOauth2ProviderConfig': {
                  'clientId': settings.github_client_id.get_secret_value(),
                  'clientSecret': settings.github_client_secret.get_secret_value()
              }
          }
      )

      provider_arn = response['credentialProviderArn']
      callback_url = response.get('callbackUrl', 'N/A')

      print(f"‚úÖ Created OAuth provider: {provider_arn}")
      print(f"\nüîó CRITICAL: Add this callback URL to your GitHub OAuth App:")
      print(f"   {callback_url}")
      print(f"\nSteps:")
      print(f"   1. Go to https://github.com/settings/developers")
      print(f"   2. Select 'AWS Coding Agent'")
      print(f"   3. Add callback URL: {callback_url}")
      print(f"   4. Save changes\n")

      return provider_arn
  ```

- [ ] Implement `scripts/setup_provider.sh` (Bash alternative)
  ```bash
  #!/bin/bash
  set -e

  REGION="${AWS_REGION:-ap-southeast-2}"
  PROVIDER_NAME="github-provider"

  # Load credentials
  if [ -f .env ]; then
      export $(grep -v '^#' .env | xargs)
  fi

  # Create provider
  echo "üì° Creating OAuth provider..."
  OUTPUT=$(aws bedrock-agentcore-control create-oauth2-credential-provider \
      --name "$PROVIDER_NAME" \
      --credential-provider-vendor GithubOauth2 \
      --oauth2-provider-config-input "{
          \"githubOauth2ProviderConfig\": {
              \"clientId\": \"$GITHUB_CLIENT_ID\",
              \"clientSecret\": \"$GITHUB_CLIENT_SECRET\"
          }
      }" \
      --region "$REGION" \
      --output json)

  CALLBACK_URL=$(echo "$OUTPUT" | jq -r '.callbackUrl // "N/A"')

  echo "‚úÖ Provider created!"
  echo ""
  echo "üîó CRITICAL: Register this callback URL in GitHub:"
  echo "   $CALLBACK_URL"
  ```

- [ ] Run provider setup
  ```bash
  # Option 1: Python
  python -m src.auth.setup_provider

  # Option 2: Bash
  chmod +x scripts/setup_provider.sh
  ./scripts/setup_provider.sh
  ```

- [ ] **CRITICAL:** Register callback URL in GitHub OAuth App
  - Copy callback URL from script output
  - Go to GitHub OAuth App settings
  - Add callback URL to "Authorization callback URL"
  - Save changes
  - **FAILURE TO DO THIS WILL BREAK OAUTH FLOW**

**Quality Gates:**
- ‚úì OAuth provider created (verify with `aws bedrock-agentcore-control list-oauth2-credential-providers`)
- ‚úì Callback URL documented in `docs/oauth_setup.md`
- ‚úì Callback URL registered in GitHub OAuth App
- ‚úì Provider name is exactly `github-provider` (case-sensitive)

### Phase 2.3: GitHub Authentication Module

**Tasks:**
- [ ] Implement `src/auth/github_auth.py`
  ```python
  """GitHub OAuth via AgentCore Identity."""
  import asyncio
  import logging
  from typing import Optional, Callable
  from bedrock_agentcore.identity.auth import requires_access_token

  logger = logging.getLogger(__name__)

  class GitHubAuth:
      """GitHub OAuth with USER_FEDERATION (3-Legged OAuth)."""

      def __init__(self, oauth_url_callback: Optional[Callable[[str], None]] = None):
          self._token: Optional[str] = None
          self._oauth_url_callback = oauth_url_callback
          self._pending_oauth_url: Optional[str] = None

      async def _on_auth_url(self, url: str):
          """Callback when OAuth URL generated."""
          self._pending_oauth_url = url
          logger.info(f"üîê GitHub Authorization URL: {url}")

          if self._oauth_url_callback:
              if asyncio.iscoroutinefunction(self._oauth_url_callback):
                  await self._oauth_url_callback(url)
              else:
                  self._oauth_url_callback(url)

      async def get_token(self) -> str:
          """Get GitHub access token via OAuth."""
          if not self._token:
              @requires_access_token(
                  provider_name='github-provider',
                  scopes=['repo', 'read:user'],
                  auth_flow='USER_FEDERATION',
                  on_auth_url=self._on_auth_url,
                  force_authentication=False
              )
              async def _get_token(*, access_token: str) -> str:
                  self._token = access_token
                  logger.info("‚úÖ GitHub token received")
                  return access_token

              await _get_token()

          return self._token

      def is_authenticated(self) -> bool:
          return self._token is not None
  ```

- [ ] Implement `src/auth/interface.py`
  ```python
  """Authentication interface for dependency injection."""
  from typing import Protocol

  class AuthProvider(Protocol):
      async def get_token(self) -> str: ...
      def is_authenticated(self) -> bool: ...
  ```

**Quality Gates:**
- ‚úì Auth module imports without errors
- ‚úì @requires_access_token decorator properly configured
- ‚úì OAuth URL callback mechanism works
- ‚úì No hardcoded credentials in code

### Phase 2.4: OAuth Documentation

**Tasks:**
- [ ] Create `docs/oauth_setup.md`
  ```markdown
  # GitHub OAuth Setup Guide

  ## Prerequisites
  - GitHub account with developer access
  - AWS credentials with bedrock-agentcore permissions
  - Python environment configured

  ## Step-by-Step Setup

  ### 1. Create GitHub OAuth App
  [Detailed steps...]

  ### 2. Run OAuth Provider Setup
  [Commands and expected output...]

  ### 3. Register Callback URL
  ‚ö†Ô∏è CRITICAL: This step is mandatory
  [Instructions with screenshots...]

  ### 4. Verify Setup
  [Verification commands...]

  ## Troubleshooting
  [Common issues and solutions...]
  ```

- [ ] Add troubleshooting section with common issues:
  - "Provider not found" ‚Üí Name mismatch
  - "Callback URL error" ‚Üí Not registered in GitHub
  - "Region not set" ‚Üí Don't pass region to list/delete operations
  - "Token not persisted" ‚Üí Check USER_FEDERATION flow

**Quality Gates:**
- ‚úì Documentation covers all setup steps
- ‚úì Troubleshooting section addresses known issues
- ‚úì Callback URL registration explicitly highlighted

---

## Phase 3: Core Agent Development

**Goal:** Create agent infrastructure with separated prompts and data models
**Duration:** 3-4 hours
**Dependencies:** Phase 1, Phase 2
**Parallel Opportunities:** Prompts and models can be developed concurrently

### Phase 3.1: Prompts & Templates

**Tasks:**
- [ ] Implement `src/prompts/system_prompts.py`
  ```python
  """System prompts for agents - separated for maintainability."""

  CODING_AGENT_SYSTEM_PROMPT = """
  You are an AI coding assistant with GitHub integration.

  **Capabilities:**
  - General coding help and technical discussions
  - PR review when explicitly requested by user
  - GitHub operations via authenticated API
  - Scoped to /agent-tasks/ folder for PR reviews

  **Workflow for PR Reviews:**
  1. Fetch PR details using GitHub API
  2. Generate structured review plan (PlanModel)
  3. Get user confirmation
  4. Execute review steps
  5. Post results as PR comment

  **Tone:** Professional, concise, technical.
  """

  PR_REVIEW_PLAN_PROMPT_TEMPLATE = """
  Analyze PR #{pr_number}: {title}

  Files changed: {files_summary}

  Generate review plan with:
  - Objective
  - Steps (specific actions)
  - Potential risks
  - Estimated time (minutes)

  Return JSON matching PlanModel schema.
  """
  ```

- [ ] Implement `src/prompts/templates.py`
  ```python
  """Template generation - pure functions."""
  from typing import List

  def generate_plan_markdown(
      objective: str,
      steps: List[str],
      risks: List[str],
      time_min: int
  ) -> str:
      """Generate PR review plan as markdown."""
      steps_md = "\n".join(f"{i+1}. {step}" for i, step in enumerate(steps))
      risks_md = "\n".join(f"- {r}" for r in risks) if risks else "None"

      return f"""## ü§ñ PR Review Plan

  **Objective:** {objective}

  **Steps:**
  {steps_md}

  **Risks:**
  {risks_md}

  **Estimated Time:** {time_min} minutes

  ---
  Reply 'approve' to proceed or 'cancel' to abort.
  """

  def generate_status_update(
      status: str,
      step: str,
      progress: int,
      issues: List[str]
  ) -> dict:
      """Generate status object for streaming."""
      from datetime import datetime
      return {
          "status": status,
          "current_step": step,
          "progress": progress,
          "issues": issues,
          "updated_at": datetime.utcnow().isoformat()
      }
  ```

**Quality Gates:**
- ‚úì All prompts separated from code
- ‚úì No hardcoded text in agent/tools modules
- ‚úì Template functions are pure (no side effects)
- ‚úì Type hints present on all functions

### Phase 3.2: Data Models

**Tasks:**
- [ ] Implement `src/models/plan.py`
  ```python
  """PR review plan model."""
  from pydantic import BaseModel, Field
  from typing import List

  class PlanModel(BaseModel):
      """Structured plan for PR review."""
      objective: str = Field(..., description="Main goal of review")
      steps: List[str] = Field(..., description="Sequential review steps")
      risks: List[str] = Field(default_factory=list,
                              description="Potential issues")
      estimated_time_minutes: int = Field(..., ge=1, le=480,
                                         description="Time estimate")
  ```

- [ ] Implement `src/models/status.py`
  ```python
  """Review status tracking."""
  from pydantic import BaseModel, Field
  from typing import List, Literal
  from datetime import datetime

  class StatusModel(BaseModel):
      """Current review status."""
      status: Literal["pending", "in_progress", "completed", "failed"]
      current_step: str
      progress: int = Field(ge=0, le=100)
      issues: List[str] = Field(default_factory=list)
      updated_at: datetime = Field(default_factory=datetime.utcnow)
  ```

- [ ] Implement `src/models/chat.py`
  ```python
  """Chat message models."""
  from pydantic import BaseModel, Field
  from typing import Literal

  class ChatMessage(BaseModel):
      """User/assistant message."""
      role: Literal["user", "assistant"]
      content: str
      session_id: str = Field(..., description="Session identifier")
  ```

**Quality Gates:**
- ‚úì All models validate sample data successfully
- ‚úì Field constraints properly defined
- ‚úì No business logic in models (data only)

### Phase 3.3: Agent Factory

**Tasks:**
- [ ] Implement `src/agent/create_agent.py`
  ```python
  """Agent factory - functional approach."""
  from strands import Agent
  from strands.models import BedrockModel
  from ..prompts.system_prompts import CODING_AGENT_SYSTEM_PROMPT
  from ..config import settings
  from ..tools.github_tools import (
      list_github_repos,
      get_repo_info,
      create_github_issue,
      list_github_issues,
      create_pull_request
  )

  def create_coding_agent() -> Agent:
      """Create Strands Agent with GitHub tools."""
      model = BedrockModel(
          model_id=settings.model_id,
          region_name=settings.aws_region
      )

      agent = Agent(
          model=model,
          tools=[
              list_github_repos,
              get_repo_info,
              create_github_issue,
              list_github_issues,
              create_pull_request
          ],
          system_prompt=CODING_AGENT_SYSTEM_PROMPT
      )

      return agent
  ```

**Quality Gates:**
- ‚úì Agent creation succeeds without errors
- ‚úì BedrockModel configured with correct region and model ID
- ‚úì System prompt loaded from prompts module
- ‚úì All tools registered (verify with agent.tools)

---

## Phase 4: GitHub Integration

**Goal:** Implement authenticated GitHub API tools
**Duration:** 4-5 hours
**Dependencies:** Phase 2 (OAuth), Phase 3 (Agent)
**Parallel Opportunities:** Individual tools can be developed concurrently

### Phase 4.1: GitHub SDK Integration

**Tasks:**
- [ ] Add PyGithub dependency
  ```bash
  uv add PyGithub
  # or
  poetry add PyGithub
  ```

- [ ] Create authenticated GitHub client wrapper
  ```python
  # src/tools/github_client.py
  """GitHub API client with OAuth token injection."""
  from github import Github
  from ..auth.github_auth import GitHubAuth

  async def get_github_client(auth: GitHubAuth) -> Github:
      """Create authenticated GitHub client."""
      token = await auth.get_token()
      return Github(token)
  ```

**Quality Gates:**
- ‚úì PyGithub installed and importable
- ‚úì Client creation succeeds with test token
- ‚úì Token injection works correctly

### Phase 4.2: GitHub Tools Implementation

**Tasks:**
- [ ] Implement `src/tools/github_tools.py`
  ```python
  """GitHub tools with OAuth authentication."""
  from github import Github
  from bedrock_agentcore.identity.auth import requires_access_token
  from typing import List, Dict, Any
  import logging

  logger = logging.getLogger(__name__)

  @requires_access_token(
      provider_name='github-provider',
      scopes=['repo', 'read:user'],
      auth_flow='USER_FEDERATION'
  )
  async def list_github_repos(
      *,
      access_token: str,
      username: str = None
  ) -> List[Dict[str, Any]]:
      """List user's GitHub repositories."""
      gh = Github(access_token)
      user = gh.get_user(username) if username else gh.get_user()

      repos = []
      for repo in user.get_repos():
          repos.append({
              "name": repo.name,
              "full_name": repo.full_name,
              "description": repo.description,
              "private": repo.private,
              "url": repo.html_url
          })

      return repos

  @requires_access_token(
      provider_name='github-provider',
      scopes=['repo'],
      auth_flow='USER_FEDERATION'
  )
  async def get_repo_info(
      *,
      access_token: str,
      repo_name: str
  ) -> Dict[str, Any]:
      """Get detailed repository information."""
      gh = Github(access_token)
      repo = gh.get_repo(repo_name)

      return {
          "name": repo.name,
          "description": repo.description,
          "stars": repo.stargazers_count,
          "forks": repo.forks_count,
          "open_issues": repo.open_issues_count,
          "language": repo.language,
          "created_at": repo.created_at.isoformat(),
          "updated_at": repo.updated_at.isoformat()
      }
  ```

- [ ] Implement `src/tools/repos.py`
  ```python
  """Repository operation tools."""
  from github import Github
  from bedrock_agentcore.identity.auth import requires_access_token
  from typing import List, Dict, Any

  @requires_access_token(
      provider_name='github-provider',
      scopes=['repo'],
      auth_flow='USER_FEDERATION'
  )
  async def create_github_issue(
      *,
      access_token: str,
      repo_name: str,
      title: str,
      body: str,
      labels: List[str] = None
  ) -> Dict[str, Any]:
      """Create a new GitHub issue."""
      gh = Github(access_token)
      repo = gh.get_repo(repo_name)

      issue = repo.create_issue(
          title=title,
          body=body,
          labels=labels or []
      )

      return {
          "number": issue.number,
          "title": issue.title,
          "url": issue.html_url,
          "state": issue.state
      }

  @requires_access_token(
      provider_name='github-provider',
      scopes=['repo'],
      auth_flow='USER_FEDERATION'
  )
  async def list_github_issues(
      *,
      access_token: str,
      repo_name: str,
      state: str = "open"
  ) -> List[Dict[str, Any]]:
      """List repository issues."""
      gh = Github(access_token)
      repo = gh.get_repo(repo_name)

      issues = []
      for issue in repo.get_issues(state=state):
          issues.append({
              "number": issue.number,
              "title": issue.title,
              "state": issue.state,
              "url": issue.html_url,
              "created_at": issue.created_at.isoformat()
          })

      return issues

  @requires_access_token(
      provider_name='github-provider',
      scopes=['repo'],
      auth_flow='USER_FEDERATION'
  )
  async def create_pull_request(
      *,
      access_token: str,
      repo_name: str,
      title: str,
      body: str,
      head: str,
      base: str = "main"
  ) -> Dict[str, Any]:
      """Create a new pull request."""
      gh = Github(access_token)
      repo = gh.get_repo(repo_name)

      pr = repo.create_pull(
          title=title,
          body=body,
          head=head,
          base=base
      )

      return {
          "number": pr.number,
          "title": pr.title,
          "url": pr.html_url,
          "state": pr.state
      }
  ```

- [ ] Add error handling and rate limiting
  ```python
  # Add to each tool
  from github import RateLimitExceededException
  import asyncio

  try:
      # API call
      pass
  except RateLimitExceededException:
      logger.warning("Rate limit exceeded, waiting...")
      await asyncio.sleep(60)
      # Retry logic
  except Exception as e:
      logger.error(f"GitHub API error: {e}")
      raise
  ```

**Quality Gates:**
- ‚úì All 5 tools implemented and working
- ‚úì @requires_access_token on every tool function
- ‚úì Rate limit handling implemented
- ‚úì Error handling covers API failures
- ‚úì Type hints on all parameters and returns

---

## Phase 5: Streaming Chat Interface

**Goal:** Implement FastAPI streaming chat with SSE
**Duration:** 5-6 hours
**Dependencies:** Phase 3 (Agent), Phase 4 (GitHub Tools)
**Parallel Opportunities:** Stream handler, session management, FastAPI app can be developed separately

### Phase 5.1: Stream Handler

**Tasks:**
- [ ] Implement `src/chat/stream_handler.py`
  ```python
  """Streaming chat with Server-Sent Events."""
  import json
  from typing import AsyncIterator
  from strands import Agent
  import structlog

  logger = structlog.get_logger()

  async def stream_agent_response(
      agent: Agent,
      message: str,
      session_id: str
  ) -> AsyncIterator[str]:
      """Stream agent responses as SSE events."""
      logger.info("streaming_response", session_id=session_id)

      try:
          async for event in agent.stream_async(message, session_id=session_id):
              if hasattr(event, 'data'):
                  # Token from LLM
                  yield f"data: {json.dumps({'type': 'token', 'content': event.data})}\n\n"

              elif hasattr(event, 'current_tool_use'):
                  # Tool execution
                  tool_info = {
                      'type': 'tool_use',
                      'tool_name': event.current_tool_use.name,
                      'tool_input': event.current_tool_use.input
                  }
                  yield f"data: {json.dumps(tool_info)}\n\n"

              elif hasattr(event, 'error'):
                  # Error
                  yield f"data: {json.dumps({'type': 'error', 'message': str(event.error)})}\n\n"
                  break

          # Done
          yield f"data: {json.dumps({'type': 'done'})}\n\n"

      except Exception as e:
          logger.error("streaming_failed", error=str(e))
          yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"
  ```

- [ ] Implement OAuth URL streaming callback
  ```python
  async def stream_oauth_url(url: str, session_id: str) -> str:
      """Format OAuth URL for streaming to client."""
      return f"data: {json.dumps({'type': 'oauth_url', 'url': url, 'session_id': session_id})}\n\n"
  ```

**Quality Gates:**
- ‚úì SSE events formatted correctly
- ‚úì Handles all event types (token, tool_use, error, done)
- ‚úì OAuth URL streamed back to client
- ‚úì Proper error handling

### Phase 5.2: Session Management

**Tasks:**
- [ ] Implement `src/chat/session.py`
  ```python
  """Session state management."""
  from typing import Dict, Any
  from datetime import datetime, timedelta

  class SessionStore:
      """In-memory session storage (MVP)."""

      def __init__(self):
          self._sessions: Dict[str, Dict[str, Any]] = {}

      def get(self, session_id: str) -> Dict[str, Any]:
          """Get session data."""
          if session_id not in self._sessions:
              self._sessions[session_id] = {
                  "created_at": datetime.utcnow(),
                  "last_active": datetime.utcnow(),
                  "messages": []
              }
          return self._sessions[session_id]

      def update(self, session_id: str, data: Dict[str, Any]):
          """Update session data."""
          session = self.get(session_id)
          session.update(data)
          session["last_active"] = datetime.utcnow()

      def cleanup_old_sessions(self, max_age_hours: int = 24):
          """Remove inactive sessions."""
          cutoff = datetime.utcnow() - timedelta(hours=max_age_hours)
          self._sessions = {
              sid: data for sid, data in self._sessions.items()
              if data["last_active"] > cutoff
          }

  # Global instance
  sessions = SessionStore()
  ```

**Quality Gates:**
- ‚úì Session creation and retrieval works
- ‚úì Session data persists across requests
- ‚úì Old sessions cleaned up automatically

### Phase 5.3: FastAPI Application

**Tasks:**
- [ ] Implement `src/main.py`
  ```python
  """Streaming chat API with FastAPI."""
  from fastapi import FastAPI
  from fastapi.responses import StreamingResponse
  from fastapi.middleware.cors import CORSMiddleware
  from pydantic import BaseModel
  from .agent.create_agent import create_coding_agent
  from .chat.stream_handler import stream_agent_response
  from .chat.session import sessions
  from .utils.logging import setup_logging
  from .config import settings
  import structlog

  setup_logging(settings.log_level)
  logger = structlog.get_logger()

  app = FastAPI(
      title="Coding Agent Chat",
      version="1.0.0",
      description="AI coding assistant with GitHub integration"
  )

  # CORS
  app.add_middleware(
      CORSMiddleware,
      allow_origins=["*"],  # Configure properly for production
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )

  # Single agent instance
  agent = create_coding_agent()

  class ChatRequest(BaseModel):
      message: str
      session_id: str

  @app.post("/chat/stream")
  async def chat_stream(request: ChatRequest):
      """Streaming chat endpoint."""
      logger.info("chat_request", session_id=request.session_id)

      # Update session
      session_data = sessions.get(request.session_id)
      session_data["messages"].append({
          "role": "user",
          "content": request.message
      })

      return StreamingResponse(
          stream_agent_response(agent, request.message, request.session_id),
          media_type="text/event-stream"
      )

  @app.get("/health")
  async def health():
      return {
          "status": "healthy",
          "agent_ready": agent is not None
      }

  @app.on_event("startup")
  async def startup():
      logger.info("application_startup")

  @app.on_event("shutdown")
  async def shutdown():
      logger.info("application_shutdown")
      sessions.cleanup_old_sessions(max_age_hours=0)  # Clean all on shutdown

  if __name__ == "__main__":
      import uvicorn
      uvicorn.run(app, host="0.0.0.0", port=8000)
  ```

**Quality Gates:**
- ‚úì FastAPI app starts without errors
- ‚úì /chat/stream endpoint returns SSE
- ‚úì /health endpoint returns 200
- ‚úì CORS configured correctly

### Phase 5.4: AgentCore Runtime Entrypoint

**Tasks:**
- [ ] Implement `src/agent/runtime.py`
  ```python
  """AgentCore Runtime entrypoint."""
  from ..main import app

  # AgentCore will import this module
  # and look for FastAPI app instance
  __all__ = ["app"]
  ```

- [ ] Verify runtime configuration
  ```yaml
  # .bedrock_agentcore.yaml should include:
  entrypoint: src/agent/runtime.py:app
  ```

**Quality Gates:**
- ‚úì Runtime entrypoint properly configured
- ‚úì AgentCore can import app instance

---

## Phase 6: Testing & Quality Assurance

**Goal:** Comprehensive testing coverage
**Duration:** 6-8 hours
**Dependencies:** All previous phases
**Parallel Opportunities:** Unit tests can be written alongside implementation

### Phase 6.1: Unit Tests

**Tasks:**
- [ ] Setup pytest infrastructure
  ```python
  # tests/conftest.py
  import pytest
  from src.config import settings

  @pytest.fixture
  def mock_github_token():
      return "ghp_test_token_1234567890"

  @pytest.fixture
  def sample_repo_data():
      return {
          "name": "test-repo",
          "full_name": "user/test-repo",
          "description": "Test repository",
          "private": False
      }
  ```

- [ ] Test configuration loading
  ```python
  # tests/test_config.py
  def test_settings_load():
      assert settings.aws_region == "ap-southeast-2"
      assert settings.model_id.startswith("anthropic")
  ```

- [ ] Test template functions
  ```python
  # tests/test_templates.py
  from src.prompts.templates import generate_plan_markdown

  def test_plan_template():
      result = generate_plan_markdown(
          objective="Review PR",
          steps=["Step 1", "Step 2"],
          risks=["Risk 1"],
          time_min=30
      )
      assert "Review PR" in result
      assert "Step 1" in result
      assert "30 minutes" in result
  ```

- [ ] Test data models
  ```python
  # tests/test_models.py
  from src.models.plan import PlanModel

  def test_plan_model_validation():
      plan = PlanModel(
          objective="Test",
          steps=["Step 1"],
          estimated_time_minutes=30
      )
      assert plan.objective == "Test"
      assert len(plan.risks) == 0  # Default empty list
  ```

**Quality Gates:**
- ‚úì All unit tests pass
- ‚úì Test coverage >80% for utilities and templates
- ‚úì No skipped tests

### Phase 6.2: Integration Tests

**Tasks:**
- [ ] Test OAuth provider setup (with test credentials)
  ```python
  # tests/integration/test_oauth.py
  import pytest
  from src.auth.setup_provider import create_github_oauth_provider

  @pytest.mark.integration
  def test_oauth_provider_creation():
      # Requires AWS credentials and test GitHub app
      provider_arn = create_github_oauth_provider()
      assert provider_arn.startswith("arn:aws")
  ```

- [ ] Test agent creation
  ```python
  # tests/integration/test_agent.py
  from src.agent.create_agent import create_coding_agent

  @pytest.mark.integration
  def test_agent_creation():
      agent = create_coding_agent()
      assert agent is not None
      assert len(agent.tools) == 5  # 5 GitHub tools
  ```

- [ ] Test GitHub tools (with mocked API)
  ```python
  # tests/integration/test_github_tools.py
  from unittest.mock import Mock, patch
  from src.tools.github_tools import list_github_repos

  @pytest.mark.asyncio
  async def test_list_repos_with_token():
      with patch('src.tools.github_tools.Github') as mock_gh:
          mock_gh.return_value.get_user.return_value.get_repos.return_value = []
          repos = await list_github_repos(access_token="test_token")
          assert isinstance(repos, list)
  ```

**Quality Gates:**
- ‚úì Integration tests pass
- ‚úì OAuth flow tested (with test provider)
- ‚úì Agent creation verified
- ‚úì Tool registration confirmed

### Phase 6.3: E2E Tests

**Tasks:**
- [ ] Test complete chat flow
  ```python
  # tests/e2e/test_chat.py
  import pytest
  from fastapi.testclient import TestClient
  from src.main import app

  @pytest.mark.e2e
  def test_chat_stream_endpoint():
      client = TestClient(app)
      response = client.post(
          "/chat/stream",
          json={
              "message": "Hello",
              "session_id": "test-session"
          }
      )
      assert response.status_code == 200
      assert response.headers["content-type"] == "text/event-stream"
  ```

- [ ] Test PR review workflow (end-to-end)
  ```python
  @pytest.mark.e2e
  async def test_pr_review_flow():
      # 1. Start chat
      # 2. Request PR review
      # 3. Verify plan generated
      # 4. Approve plan
      # 5. Verify review completion
      pass  # Implement full flow
  ```

- [ ] Test OAuth URL generation and callback
  ```python
  @pytest.mark.e2e
  async def test_oauth_url_streaming():
      # Simulate first-time user
      # Verify OAuth URL streamed
      # Mock user authorization
      # Verify token received
      pass  # Implement OAuth flow test
  ```

**Quality Gates:**
- ‚úì E2E tests pass
- ‚úì Complete chat flow verified
- ‚úì OAuth flow works end-to-end
- ‚úì No critical security vulnerabilities (run security scan)

---

## Phase 7: Deployment & Validation

**Goal:** Deploy to AgentCore and validate production readiness
**Duration:** 4-5 hours
**Dependencies:** Phase 6 (tests passing)
**Critical Path:** Configuration ‚Üí Containerization ‚Üí Deployment ‚Üí Validation

### Phase 7.1: AgentCore Configuration

**Tasks:**
- [ ] Run agentcore configure
  ```bash
  agentcore configure \
      -e src/agent/runtime.py \
      --region ap-southeast-2 \
      --non-interactive
  ```

- [ ] Update `.bedrock_agentcore.yaml`
  ```yaml
  agent_name: coding-agent
  entrypoint: src/agent/runtime.py:app
  runtime: python3.11

  oauth_configuration:
    workload_name: coding-agent-workload
    credential_providers:
      - github-provider  # Must match provider name exactly

  environment:
    AWS_REGION: ap-southeast-2
    MODEL_ID: anthropic.claude-3-5-sonnet-20241022-v2:0
    LOG_LEVEL: INFO
  ```

- [ ] Verify configuration syntax
  ```bash
  agentcore validate-config
  ```

**Quality Gates:**
- ‚úì Configuration file valid YAML
- ‚úì Entrypoint path correct
- ‚úì OAuth provider name matches exactly
- ‚úì Environment variables properly set

### Phase 7.2: Docker Containerization

**Tasks:**
- [ ] Create `Dockerfile`
  ```dockerfile
  FROM python:3.11-slim

  WORKDIR /app

  # Install uv
  RUN pip install uv

  # Copy dependency files
  COPY pyproject.toml .
  COPY uv.lock .

  # Install dependencies
  RUN uv sync --frozen

  # Copy source code
  COPY src/ src/

  # Expose port
  EXPOSE 8000

  # Entrypoint for AgentCore
  CMD ["uv", "run", "uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8000"]
  ```

- [ ] Test local container build
  ```bash
  docker build -t coding-agent:local .
  docker run -p 8000:8000 --env-file .env coding-agent:local
  ```

- [ ] Verify container health
  ```bash
  curl http://localhost:8000/health
  # Should return: {"status": "healthy", "agent_ready": true}
  ```

**Quality Gates:**
- ‚úì Docker image builds successfully
- ‚úì Container starts without errors
- ‚úì Health endpoint accessible
- ‚úì Environment variables loaded correctly

### Phase 7.3: Deployment & Validation

**Tasks:**
- [ ] Deploy to AgentCore
  ```bash
  agentcore launch -a coding-agent
  ```

- [ ] Verify deployment status
  ```bash
  agentcore status -a coding-agent
  ```

- [ ] Test OAuth flow with real user
  ```bash
  # Send chat request
  curl -X POST https://<agent-url>/chat/stream \
      -H "Content-Type: application/json" \
      -d '{
        "message": "List my repositories",
        "session_id": "user-123"
      }'

  # Should stream OAuth URL
  # User visits URL and authorizes
  # Subsequent requests should work without re-auth
  ```

- [ ] Monitor CloudWatch logs
  ```bash
  agentcore logs -a coding-agent --tail --follow
  ```

- [ ] Run smoke tests
  - [ ] Health check
  - [ ] OAuth flow
  - [ ] List repositories
  - [ ] Get repo info
  - [ ] Create issue (in test repo)

- [ ] Document deployment
  - [ ] AgentCore URL
  - [ ] OAuth provider ARN
  - [ ] CloudWatch log group
  - [ ] Deployment date and version

**Quality Gates:**
- ‚úì Deployment completes successfully
- ‚úì Agent accessible via AgentCore URL
- ‚úì OAuth flow works with real GitHub
- ‚úì All smoke tests pass
- ‚úì No errors in CloudWatch logs for 1 hour
- ‚úì Deployment documented

---

## Critical Path Analysis

### Path 1: OAuth Infrastructure (Longest Critical Path)
```
Phase 1 (3h) ‚Üí Phase 2.1 (1h) ‚Üí Phase 2.2 (2h) ‚Üí Phase 2.3 (2h) ‚Üí Phase 4 (5h)
Total: 13 hours
```

### Path 2: Agent Development
```
Phase 1 (3h) ‚Üí Phase 3 (4h) ‚Üí Phase 5 (6h)
Total: 13 hours
```

### Path 3: Quality & Deployment
```
Phase 6 (8h) ‚Üí Phase 7 (5h)
Total: 13 hours
```

**Overall Critical Path:** 28-36 hours sequential | 18-26 hours with parallelization

---

## Risk Mitigation Strategies

### High-Risk Items

#### 1. OAuth Callback URL Not Registered
**Risk:** OAuth flow fails silently
**Impact:** High - blocks all GitHub integration
**Mitigation:**
- Automated verification script after provider creation
- Checklist in documentation with screenshots
- Pre-deployment verification step

**Verification Script:**
```bash
#!/bin/bash
# scripts/verify_oauth.sh

echo "Verifying OAuth setup..."

# Get callback URL
CALLBACK_URL=$(aws bedrock-agentcore-control get-oauth2-credential-provider \
    --name "github-provider" \
    --region ap-southeast-2 | jq -r '.callbackUrl')

echo "Callback URL: $CALLBACK_URL"
echo ""
echo "‚ö†Ô∏è  VERIFY: Is this URL registered in your GitHub OAuth App?"
echo "   Go to: https://github.com/settings/developers"
echo "   Check: Authorization callback URL"
echo ""
read -p "Is callback URL registered? (yes/no): " CONFIRMED

if [ "$CONFIRMED" != "yes" ]; then
    echo "‚ùå OAuth setup incomplete. Register callback URL first."
    exit 1
fi

echo "‚úÖ OAuth verification complete"
```

#### 2. Region Parameter Errors
**Risk:** Boto3 calls fail with "region not set" error
**Impact:** Medium - breaks provider operations
**Mitigation:**
- Centralized client creation in config.py
- Never pass region to list/delete operations
- Code review checklist

**Safe Pattern:**
```python
# ‚úÖ Correct
client = boto3.client('bedrock-agentcore-control', region_name=settings.aws_region)
providers = client.list_oauth2_credential_providers()

# ‚ùå Wrong
providers = client.list_oauth2_credential_providers(region=settings.aws_region)
```

#### 3. Token Persistence Issues
**Risk:** Tokens not persisted across sessions
**Impact:** High - requires re-auth every time
**Mitigation:**
- Explicit USER_FEDERATION auth flow
- Validation in tests
- Monitoring for re-auth frequency

**Validation:**
```python
@requires_access_token(
    auth_flow='USER_FEDERATION',  # MUST be USER_FEDERATION for persistence
    force_authentication=False     # Don't force re-auth if token exists
)
```

### Medium-Risk Items

#### 1. GitHub API Rate Limits
**Risk:** Development/testing blocked by rate limits
**Impact:** Medium - slows development
**Mitigation:**
- Implement exponential backoff
- Add response caching
- Use conditional requests (ETags)

#### 2. AgentCore Deployment Failures
**Risk:** Deployment fails due to configuration issues
**Impact:** Medium - delays production
**Mitigation:**
- Validate config before deployment
- Test in staging environment first
- Comprehensive logging

#### 3. Streaming SSE Complexity
**Risk:** Real-time streaming has edge cases
**Impact:** Medium - UX degradation
**Mitigation:**
- Start with simple streaming
- Progressive enhancement
- Fallback to polling if needed

---

## Parallel Execution Optimization

### Batch 1: After Phase 1 Complete (Can run in parallel)
- Phase 2.1: GitHub OAuth App setup (manual, 1 hour)
- Phase 3.1: Prompts/Templates (2 hours)
- Phase 3.2: Data Models (1 hour)

**Time Saved:** 2 hours (4 hours total vs 2 hours parallel)

### Batch 2: After Phase 2.2 Complete
- Phase 2.3: Auth module (2 hours)
- Phase 4.1: GitHub SDK integration (1 hour)

**Time Saved:** 1 hour

### Batch 3: After Phase 3, 4 Complete
- Phase 5.1: Stream handler (2 hours)
- Phase 5.2: Session management (1 hour)
- Phase 5.3: FastAPI app (2 hours)
- Phase 6.1: Unit tests (parallel to implementation)

**Time Saved:** 3-4 hours

### Batch 4: Testing Phase
- Phase 6.1: Unit tests
- Phase 6.2: Integration tests
- Phase 6.3: E2E tests (some dependencies)

**Time Saved:** 2-3 hours

**Total Time Savings:** 8-10 hours (25-30% reduction)

---

## Quality Gates Checklist

### Phase 1 ‚úì
- [ ] Project builds successfully
- [ ] All directories exist
- [ ] Configuration loads
- [ ] Logging works

### Phase 2 ‚úì
- [ ] OAuth provider created
- [ ] Callback URL registered in GitHub
- [ ] Auth module tests pass
- [ ] OAuth URL callback works

### Phase 3 ‚úì
- [ ] Prompts separated from code
- [ ] Models validate data
- [ ] Agent creation succeeds

### Phase 4 ‚úì
- [ ] All 5 GitHub tools work
- [ ] Rate limiting implemented
- [ ] Error handling complete

### Phase 5 ‚úì
- [ ] SSE streaming works
- [ ] OAuth URL streamed
- [ ] Session persistence works
- [ ] Health endpoint returns 200

### Phase 6 ‚úì
- [ ] Unit test coverage >80%
- [ ] Integration tests pass
- [ ] E2E flow complete
- [ ] Security scan clean

### Phase 7 ‚úì
- [ ] Configuration validates
- [ ] Docker image builds
- [ ] Deployment succeeds
- [ ] Live OAuth flow tested
- [ ] No errors in logs (1 hour)

---

## Sprint Planning Recommendation

### Sprint 1 (Day 1): Foundation + OAuth Setup
- **Morning:** Phase 1 (Foundation)
- **Afternoon:** Phase 2.1-2.2 (OAuth App + Provider)
- **Deliverable:** OAuth provider created and verified

### Sprint 2 (Day 2): Authentication + Core Agent
- **Morning:** Phase 2.3-2.4 (Auth module + docs)
- **Afternoon:** Phase 3 (Prompts + Models + Agent)
- **Deliverable:** Agent can be created with auth

### Sprint 3 (Day 3): GitHub Integration + Streaming Start
- **Morning:** Phase 4 (GitHub tools)
- **Afternoon:** Phase 5.1-5.2 (Stream handler + sessions)
- **Deliverable:** GitHub tools working with OAuth

### Sprint 4 (Day 4): Complete Streaming + Testing
- **Morning:** Phase 5.3-5.4 (FastAPI + Runtime)
- **Afternoon:** Phase 6 (Testing)
- **Deliverable:** Full chat flow working

### Sprint 5 (Day 5): Deployment + Validation
- **Morning:** Phase 7 (Deployment)
- **Afternoon:** Validation and documentation
- **Deliverable:** Production-ready agent deployed

---

## Post-Deployment Checklist

### Immediate (Day 1)
- [ ] Verify OAuth flow with 3+ real users
- [ ] Monitor CloudWatch logs for errors
- [ ] Test all GitHub tools in production
- [ ] Document any issues encountered

### Week 1
- [ ] Monitor token refresh patterns
- [ ] Analyze streaming performance
- [ ] Collect user feedback
- [ ] Review error rates

### Month 1
- [ ] Optimize based on usage patterns
- [ ] Add monitoring dashboards
- [ ] Document lessons learned
- [ ] Plan Phase 2 features

---

## Success Metrics

### Technical Metrics
- OAuth success rate: >95%
- API response time: <2s (p95)
- Streaming latency: <500ms (first token)
- Error rate: <1%
- Test coverage: >80%

### Operational Metrics
- Deployment time: <10 minutes
- Zero-downtime deployments
- CloudWatch alerts configured
- Automated rollback available

### User Metrics
- Time to first response: <3s
- OAuth completion rate: >90%
- User session duration: >5min average
- PR review accuracy: Manual validation

---

## Troubleshooting Guide

### OAuth Issues

**Problem:** "Provider not found"
**Solution:**
```bash
# Verify provider name exactly matches
aws bedrock-agentcore-control list-oauth2-credential-providers --region ap-southeast-2
# Check: name = "github-provider" (case-sensitive)
```

**Problem:** "Callback URL error"
**Solution:**
- Verify URL registered in GitHub OAuth App
- Check URL matches exactly (no trailing slash)
- Run verification script

**Problem:** "Token not persisted"
**Solution:**
```python
# Ensure USER_FEDERATION flow
@requires_access_token(
    auth_flow='USER_FEDERATION',  # Not CLIENT_CREDENTIALS
    force_authentication=False     # Don't force re-auth
)
```

### Deployment Issues

**Problem:** "Region not set"
**Solution:**
```python
# Never pass region to list/delete
client = boto3.client('bedrock-agentcore-control', region_name=region)
client.list_oauth2_credential_providers()  # No region param
```

**Problem:** "Deployment fails"
**Solution:**
```bash
# Validate config first
agentcore validate-config
# Check logs
agentcore logs -a coding-agent --tail
```

### Runtime Issues

**Problem:** "Streaming not working"
**Solution:**
- Check SSE event format
- Verify Content-Type: text/event-stream
- Test with curl first

**Problem:** "GitHub API rate limit"
**Solution:**
- Check rate limit headers
- Implement exponential backoff
- Use conditional requests (ETags)

---

## Next Steps After MVP

### Phase 8: Enhanced Features (Future)
- Persistent session storage (Redis/DynamoDB)
- Multi-repo support
- Advanced PR analysis (AST parsing, security scanning)
- Webhook integration for auto-reviews
- Team collaboration features

### Phase 9: Production Hardening
- Load testing and optimization
- Multi-region deployment
- Advanced monitoring and alerting
- Disaster recovery procedures
- Cost optimization

### Phase 10: AI Enhancements
- Fine-tuned models for code review
- Custom prompts per repository
- Learning from user feedback
- Integration with CI/CD pipelines

---

## References

- Architecture Document: `/Users/freedom/ai/aws-coding-agent/draft.md`
- Template Reference: `/Users/freedom/ai/bedrock-agent-template/agents/github-agent/`
- AgentCore Docs: https://docs.aws.amazon.com/bedrock-agentcore/
- Strands Agents SDK: https://github.com/aws-samples/strands-agents-sdk
- GitHub OAuth: https://docs.github.com/en/apps/oauth-apps

---

**Document Version:** 1.0
**Last Updated:** 2025-10-29
**Status:** Ready for implementation
